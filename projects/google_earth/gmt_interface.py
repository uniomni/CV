"""Module to interface to parts of the gmt package.
It is assumed that gmt commands are available on the system path.

FIXME: Works only for RGB so far
"""


from Numeric import array
from tempfile import mkstemp
from math import log, floor
import os

# Colour Palette Table

def readcpt(filename):
    f = open(filename,'r')
    lines = f.readlines()
    f.close()
    return lines
	

def format_string(x):
    """Determine optimal format string for x
    """
    
    if 1.0>abs(x)>0.0:   
        lg = log(abs(x))/log(10)
        
        # Number of digits
        d = -int(floor(lg))

        return '%%.%df' %d
    else:
        return '%.f'
    
        
                
class Color_segment:

    def __init__(self, lower_bound, rgb_min,
                 upper_bound, rgb_dif,
                 color_segment_boundary):
                 
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound        
        self.rgb_min = rgb_min
        self.rgb_dif = rgb_dif
        self.color_segment_boundary = color_segment_boundary
                
    
    
            
class CPT:
    """Object representation of a GMT colour palette table (cpt)
    Internally, this will take the form of list with entries:
    [min, max], RGB_min, RGB_dif
    
    where min, max are the bounds of the value to be interpolated,
    RGB_min is a vector of the 3 RGB values to be assigned to the
    lower value of the interval while RGB_dif is the difference
    between the RGB values assigned to the upper value of the interval
    and RGB_min
    """

    def __init__(self, 
                 filename=None):

        self.segments = []
        self.color_model = 'RGB'                        
        if filename is not None:
            lines=readcpt(filename)

            for line in lines:
		fields = line.split()
                f0 = fields[0].lstrip().upper()
                
                if f0.startswith('#'):
                    # This is a comment line
                    
                    if f0 == '#COLOR_MODEL':
                        self.color_model = fields[-1].strip().upper()
                        assert self.color_model in ['RGB', 'HSV']
                    continue    
                
                # Read the first set of rgb values
                r = float(fields[1])
                g = float(fields[2])
                b = float(fields[3])              
                rgb = array([r,g,b])                          
                    

                if f0 in ['B', 'F', 'N']:
                    assert len(fields) == 4
                    
                    if f0 == 'B':
                        self.background_color = rgb
                    elif f0 == 'F':
                        self.foreground_color = rgb		    
                    elif f0 == 'N':
                        self.nan_color = rgb		    		    
		    else:
                        msg = 'Unknown symbol: %s' %f0
                        raise Exception, msg
                    continue
			    

                # Now read the color table itself   

                # Interval
                lower_bound = float(fields[0])
                upper_bound = float(fields[4])
                
                # RGB value for lower bound
                rgb_min = rgb
                
                # RGB value for upper bound (stored as difference)
                r = float(fields[5])
                g = float(fields[6])
                b = float(fields[7])              
                rgb = array([r,g,b])                          
                rgb_dif = rgb-rgb_min

                # Colour segment boundary flag if any  (L, U, B)		
                try:
                    color_segment_boundary = fields[8]
                except:
                    color_segment_boundary = ''
                    
                assert color_segment_boundary in ['', 'L', 'U', 'B']     

                                
                # Store this segment
                segment = Color_segment(lower_bound, rgb_min,
                                        upper_bound, rgb_dif,
                                        color_segment_boundary)                
                
                
                self.segments.append(segment)
        else:
            # No filename present
            pass

    def __repr__(self):
        """Textual representation of cpt object.

        This is almost the inverse of __init__ inasmuch as it returns
        the contents of the file used to initialise the cpt object 
        """
        
        s = '#cpt palette generated by gmt_interface.py\n'
        s += '#COLOR_MODEL = %s\n' %self.color_model
        s += '#\n'
        
        for seg in self.segments:

            #print x, seg
            xmin = seg.lower_bound
            xmax = seg.upper_bound

            rgb_min = seg.rgb_min
            rgb_max = rgb_min + seg.rgb_dif
            
            # Determine number of decimal points
            xmax-xmin
            
            fmin = format_string(xmin)            
            fmax = format_string(xmax)

            s += fmin %xmin
            s += ' %d %d %d ' %(rgb_min[0], rgb_min[1], rgb_min[2]) 
            s += fmax %xmax
            s += ' %d %d %d ' %(rgb_max[0], rgb_max[1], rgb_max[2])
            s += ' %s' %seg.color_segment_boundary
            s += '\n'
            
        return s


    def get_color(self, x):
        """Get interpolated color
        """
        
        assert self.color_model == 'RGB'
        
        found = False
        for seg in self.segments:
            #print x, seg
            xmin = seg.lower_bound
            xmax = seg.upper_bound
            if xmin <= x <= xmax:
                found = True

                alpha = (x-xmin)/(xmax-xmin) # Normalise
                rgb = seg.rgb_min + alpha*seg.rgb_dif

                break    
                
        
        if found is True:
            return rgb
        else:
            msg = 'Colour could not be found for x = %f' %x
            raise Exception, msg


    def normalise(self):
        """Normalise range to unit interval.
        Leaving colour definitions unchanged.

        This function changes the cpt object.

        Return min and max
        """

        # Find extrema
        xmin = self.segments[0].lower_bound
        xmax = self.segments[0].upper_bound
        for seg in self.segments[1:]:
            xmin = min(xmin, seg.lower_bound)
            xmax = max(xmax, seg.upper_bound)

        range = xmax-xmin    

        # Normalise
        for seg in self.segments:
            seg.lower_bound = (seg.lower_bound-xmin)/range
            seg.upper_bound = (seg.upper_bound-xmin)/range

        # Return
        return xmin, xmax


    def rescale(self, xmin, xmax):
        """Rescale palette to specified range irrespective of current range.
        Leave colour definitions unchanged.

        This function changes the cpt object.
        """

        # Normalise
        self.normalise()

        
        # Rescale
        range = xmax-xmin
        for seg in self.segments:
            seg.lower_bound = seg.lower_bound*range + xmin
            seg.upper_bound = seg.upper_bound*range + xmin


    def create_legend_for_colour_coding(self, min_amp, max_amp, 
                                        caption,
                                        file_type = 'png',
                                        directory='.',
                                        units = ''):
        """Convert cpt file normalised to unit interval to colour legend file

         requires GMT and imageMagick
        
        
         Return name of graphics to be used as legend.
         

         file_type would typically be png or jpg
        """
    
        msg = 'Argument "caption" must be a string. I got %s'\
            %str(caption)
        assert isinstance(caption, basestring), msg

        
        # Derive filename from specified caption
        legend_filename = os.path.join(directory, 
                                       caption.replace(' ', '_') + '.' + file_type)
   
    
        # First scale cpt object mapped to actual range and store
        self.rescale(min_amp, max_amp)

        tmp_fd , tmp_name = mkstemp(suffix='.cpt', dir=directory)
        fid = os.fdopen(tmp_fd, 'w')
        fid.write(str(self))
        fid.close()        

        # Then call GMT to generate postscript legend 

        command = 'gmtset ANNOT_FONT_SIZE 12p; '
        command += 'gmtset LABEL_FONT_SIZE 14p; '
        command += 'gmtset TICK_LENGTH 0.0c; '

        #s = 'psscale -C%s -D6.5/2/9.5/0.5h -B:"%s":/:%s: -P -S'\
        # FIXME (OLE): Why did this have to change?
        s = 'psscale -C%s -D3/2/5/0.5h -B:"%s":/:%s: -P -S'\
        %(tmp_name, caption, units)

        _ , ps_filename = mkstemp(suffix='.ps', dir=directory)
        
        command += '%s > %s' %(s, ps_filename)
        #print command
        os.system(command)
        
        
        
        # Use imagemagick to crop, add border and convert to png (or jpg)
        
        command = 'convert %s -trim ' %ps_filename 
        command += ' -border 2% -bordercolor white '
        command += '%s' %legend_filename 
       
        #print command
        os.system(command)
        
        # Clean up
        os.remove(tmp_name)        
        os.remove(ps_filename)                
        

        return legend_filename
